//========================================================================================
// quicksort-loesung.jas:
// Niklas Lampe und Thade Struckhoff, 2021
// COMARCH - Versuchsaufgabe 3
// Musterl√∂sung
//
// Beschreibung:
//    Programm zur Eingabe von 2 Zahlen in hexadezimaler Form, 
//    das den groessten gemeinsamen Teiler (ggT) dessen ermittelt.
//
//  Hinweis:
//    
//========================================================================================

.constant
OBJREF 0x40				// benoetigt fuer Methodenaufrufe
.end-constant


.main                   	      // start des Programms
.var					      // Variablen fuer das Hauptprogram

a1
a2
a3
a4
a5

.end-var
      LDC_W OBJREF		// Dez: 312
      BIPUSH 0x0
      BIPUSH 0x0
      BIPUSH 0x1
      BIPUSH 0x38
	INVOKEVIRTUAL fillByte
      ISTORE a1
      
      LDC_W OBJREF		// Dez: 2.145.698
      BIPUSH 0x0
      BIPUSH 0x20
      BIPUSH 0xBD
      BIPUSH 0xA2
	INVOKEVIRTUAL fillByte
      ISTORE a2

      LDC_W OBJREF		// Dez: 836.800.936
      BIPUSH 0x31
      BIPUSH 0xE0
      BIPUSH 0x91
      BIPUSH 0xA8
	INVOKEVIRTUAL fillByte
      ISTORE a3

      LDC_W OBJREF		// Dez: 806.693.052
      BIPUSH 0x30
      BIPUSH 0x15
      BIPUSH 0x28
      BIPUSH 0xBC
	INVOKEVIRTUAL fillByte
      ISTORE a4

      BIPUSH 0xD8             // Dez: 216
      ISTORE a5

      // hier Sortieren



      
      // Sortierung ausgeben - ACHTUNG: DARF NICHT MANIPULIERT WERDEN!
      LDC_W OBJREF
      ILOAD a5
      INVOKEVIRTUAL print
      LDC_W OBJREF
      ILOAD a4
      INVOKEVIRTUAL print
      LDC_W OBJREF
      ILOAD a3
      INVOKEVIRTUAL print
      LDC_W OBJREF
      ILOAD a2
      INVOKEVIRTUAL print
      LDC_W OBJREF
      ILOAD a1
      INVOKEVIRTUAL print

      
      //BIPUSH 0x20             // print Space
      //OUT 
      
      
      HALT              // Programm beenden
.end-main


.method fillByte (in1, in2, in3, in4)
.var
counter
.end-var
      BIPUSH 0x3
      ISTORE counter

      ILOAD in4
      ILOAD in3
      ILOAD in2
      ILOAD in1
      GOTO shift
      

shift1: IINC counter -1
      IADD
      ILOAD counter     // abbruch bedingung
      IFEQ return
shift: DUP              // shift current bit
	IADD
	DUP
      IADD
	DUP
	IADD
	DUP
	IADD
      DUP
      IADD
	DUP
	IADD
	DUP
	IADD
      DUP
	IADD
      GOTO shift1
return: IRETURN         // shifted byte ist noch auf stack
.end-method

// --------------------------------------------------------------------
// Methode: print
// Parameter: total
// Beschreibung:
//    Wandelt eine Zahl in eine Zeichenkette um und gibt diese 
//    aus. Alle Zeichen werden auf den Stack geschoben, die 
//    niederwertigste Stelle zuerst, danach werden sie abgehoben
//    und gedruckt.
// --------------------------------------------------------------------
.method print( total )
.var
place
index
.end-var

print: BIPUSH 0x9		      // Es gibt 8 Nibbles in jedem Integer - das 
                              // Einstellen auf neun schiebt 10 Zeichen auf 
                              // den Stack, also insgesamt zehn gedruckte 
                              // Ziffern. 
                              // ACHTUNG: Durch die Einstellung weniger 
                              // werden die beiden fuehrenden Nullen nicht 
                              // entfernt, sondern nur die signifikanten 
                              // Ziffern.
	ISTORE index
	BIPUSH 0x1		      // Vergleichsbit
	ISTORE place
print1: BIPUSH 0x0
	ILOAD index		      // index = index - 1
	BIPUSH 0x1
	ISUB
	DUP
	IFEQ pall		      // if index = 0  goto pall
	ISTORE index            // else ...
	ILOAD total		      
	ILOAD place		
	IAND			      // if 1. Bit des aktuellen Nibbles Null ist (Total & Place)
	IFEQ print2		      //    goto print2
	BIPUSH 0x1		      // else erstes Bit des Zeichens setzen
	IADD
print2: ILOAD place		// place = place << 1 
	DUP
	IADD
	ISTORE place
	ILOAD total
	ILOAD place
	IAND			      // if 2. Bit des aktuellen Nibbles Null ist (Total & Place)
	IFEQ print3		      //    goto print3
	BIPUSH 0x2		      // else zweites Bit des Zeichens setzen
	IADD	
print3: ILOAD place		// place = place << 1
	DUP
	IADD
	ISTORE place
	ILOAD total
	ILOAD place
	IAND			      // if 3. Bit des aktuellen Nibbles Null ist (Total & Place)
	IFEQ print4		      //    goto print4
	BIPUSH 0x4		      // else zweites Bit des Zeichens setzen
	IADD	
print4: ILOAD place		// place = place << 1
	DUP
	IADD
	ISTORE place
	ILOAD total
	ILOAD place
	IAND			      // if 4. Bit des aktuellen Nibbles Null ist (Total & Place)
	IFEQ print5		      //    goto print5
	BIPUSH 0x8		      // else zweites Bit des Zeichens setzen
	IADD	
print5: ILOAD place		// place = place << 1
	DUP
	IADD
	ISTORE place
	GOTO print1
	
pall: POP			      // Fuehrende 0's abschneiden
	POP
	BIPUSH 0x9
	ISTORE index
pall1: ILOAD index		// index = index - 1
	BIPUSH 0x1
	ISUB
	DUP
	IFEQ return		      // if index = 0  return
	ISTORE index
	DUP
	BIPUSH 0xa		      // else if Zeichen < 0xa goto pall1
	ISUB
	IFLT pall2
	BIPUSH 0x37		      // else Zeichen in "A"-"F" umwandeln
	IADD
	OUT			      // print Zeichen
	GOTO pall1		      // goto pall (naechstes Zeichen vorbereiten & ausgeben)
pall2: BIPUSH 0x30		// convert Zeichen in "0"-"9" umwandeln
	IADD
	OUT			      // print Zeichen
	GOTO pall1		      // goto pall1 (naechstes Zeichen vorbereiten & ausgeben)
return: BIPUSH 0xa		// print cr (neue Zeile)
	OUT
	IRETURN			// kein Rueckgabewert
.end-method